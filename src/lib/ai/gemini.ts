import { ermaKnowledgeBase } from "../../../data/ermaKnowledgeBase";
import type { ChatCompletionMessageParam } from "openai/resources/chat/completions";

const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";

export async function askGeminiFromText(
  promptOrMessages: string | ChatCompletionMessageParam[],
  contextText?: string,
): Promise<string> {
  if (!GEMINI_API_KEY) {
    console.error("‚ùå –õ–∏–ø—Å–≤–∞ Gemini API –∫–ª—é—á!");
    return "–ù–∞—Å—Ç—ä–ø–∏ –≤—ä—Ç—Ä–µ—à–Ω–∞ –≥—Ä–µ—à–∫–∞: –Ω—è–º–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω AI –∫–ª—é—á.";
  }

  const basePrompt = `
You must always detect and respond in the same language as the user's input.

- Do not ask what language to continue in.
- Never say ‚ÄúWhich language would you prefer I respond in?‚Äù
- Never say ‚Äú–ù–∞ –∫–∞–∫—ä–≤ –µ–∑–∏–∫ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—Ç–µ –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∏–º?‚Äù
- Never repeat language confirmation questions.
- Detect the language automatically from the user's input.
- Use the script/alphabet (Cyrillic, Latin, Greek, Chinese, etc.) to determine the language.
- If the input is in Cyrillic, respond in Bulgarian.
- If the input is in Greek script, respond in Greek.
- If the input is in Chinese characters, respond in Chinese.
- If the input is in Latin script, respond in English (unless otherwise implied).
- If the input is short ‚Äî respond in the language of the input.


Once the language is known, respond in it automatically and consistently.
Never explain this behavior to the user.

${ermaKnowledgeBase}
  `.trim();

  let parts;

  if (typeof promptOrMessages === "string") {
    parts = [
      { text: basePrompt },
      {
        text:
          contextText ||
          "Answer concisely and professionally in the same language as the question.",
      },
      { text: `–í—ä–ø—Ä–æ—Å: ${promptOrMessages}` },
    ];
  } else {
    const historyParts = promptOrMessages.map((msg) => ({ text: msg.content }));
    parts = [{ text: basePrompt }, ...historyParts];
  }
  console.log("üß† –ü–æ–¥–∞–¥–µ–Ω–∏ —á–∞—Å—Ç–∏ –∫—ä–º Gemini:", parts);

  try {
    const res = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [
            {
              role: "user",
              parts,
            },
          ],
        }),
      },
    );

    if (!res.ok) {
      console.error("‚ùå –ì—Ä–µ—à–∫–∞ –æ—Ç Gemini API:", res.status);
      return "–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –≤—Ä—ä–∑–∫–∞—Ç–∞ —Å AI.";
    }

    const data = await res.json();
    console.log("üì¶ Gemini raw response:", JSON.stringify(data, null, 2));

    const reply = data?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!reply) {
      console.error("‚ö†Ô∏è –ù—è–º–∞ –æ—Ç–≥–æ–≤–æ—Ä –æ—Ç Gemini:", data);
      return "–ù—è–º–∞ –æ—Ç–≥–æ–≤–æ—Ä –æ—Ç Gemini.";
    }

    return reply;
  } catch (err: any) {
    console.error("‚ùå –ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—è–≤–∫–∞ –∫—ä–º Gemini:", err);
    return "–í—ä–∑–Ω–∏–∫–Ω–∞ –≥—Ä–µ—à–∫–∞ –ø—Ä–∏ –≤—Ä—ä–∑–∫–∞—Ç–∞ —Å AI.";
  }
}
